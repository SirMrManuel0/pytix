{"config":{"lang":["en","fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to pylix","text":""},{"location":"#get-started","title":"Get Started","text":"<p>It is required for python to at least be of version 3.12</p> <pre><code>pip install pylix\n</code></pre>"},{"location":"algebra/Matrix/","title":"Matrix","text":"<p>A class representing a mathematical matrix with various operations like addition, subtraction, multiplication, and more. The matrix can be created from a 2D list of numbers or initialized as a zero matrix. It supports operations with other matrices and scalar values, and provides methods for accessing and modifying matrix components. This matrix is iterable.</p> <p>Une classe qui repr\u00e9sente une matrice math\u00e9matique. Elle a diff\u00e9rentes m\u00e9thodes comme l'addition, la soustraction, multiplication et plus encore. La matrice peut \u00eatre cr\u00e9\u00e9e \u00e0 partir d'une liste de nombres en 2D ou initialis\u00e9e en tant que matrice z\u00e9ro. Elle prend en charge les op\u00e9rations avec d'autres matrices et valeurs scalaires, et fournit des m\u00e9thodes pour acc\u00e9der aux composants de la matrice et les modifier. Cette matrice est it\u00e9rable.</p> <p>Examples:</p> <p>Access Components:</p> <p><pre><code>from pylix.algebra import Matrix\n\nm: Matrix = Matrix([[1, 2], [3, 4]])\n\nprint(m[0][1])\nprint(m[-1][-1])\n</code></pre> output<pre><code>2\n4\n</code></pre></p> <p>Equal:</p> <p><pre><code>from pylix.algebra import Matrix\n\nm: Matrix = Matrix([[1, 2], [3, 4]])\nn: Matrix = Matrix([[1, 2], [3, 4]])\n\nprint(n == m)\n</code></pre> output<pre><code>True\n</code></pre></p> <p>Addition:</p> <p><pre><code>from pylix.algebra import Matrix\n\nm: Matrix = Matrix([[1, 2], [3, 4]])\n\nprint(m + m)\n</code></pre> output<pre><code>[\n    [2, 4],\n    [6, 8]\n]\n</code></pre></p>"},{"location":"algebra/Matrix/#create_identity_matrixn2","title":"create_identity_matrix(n=2)","text":"<p><code>classmethod</code></p> <p>Creates an identity matrix of size n x n.</p> <p>Cr\u00e9e une matrice unit\u00e9.</p> <p>default n = 2</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix\n\nprint(Matrix.create_identity_matrix(2))\n</code></pre> output<pre><code>[\n    [1, 0],\n    [0, 1]\n]\n</code></pre></p>"},{"location":"algebra/Matrix/#rotation-matrix-2d","title":"rotation matrix 2D","text":"<p><code>classmethod</code></p> <p>Creates a rotation matrix (counterclockwise) for a 2D vector.</p> <p>Cr\u00e9e une matrice de rotation (anti-horaire) pour un 2D vecteur.</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix\n\nprint(Matrix.create_rotation_matrix_2D(90))\n</code></pre> output<pre><code>[\n    [0, -1],\n    [1, 0]\n]\n</code></pre></p>"},{"location":"algebra/Matrix/#rotation-matrix-3d","title":"rotation matrix 3D","text":"<p><code>classmethod</code></p> <p>Creates a rotation matrix (counterclockwise) for a 3D vector.</p> <p>Cr\u00e9e une matrice de rotation (anti-horaire) pour un 3D vecteur.</p> <p>An Axis needs to be given:</p> <pre><code>from pylix.algebra import Axis\n\nAxis.X\nAxis.Y\nAxis.Z\n</code></pre> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix, Axis\n\nprint(Matrix.create_rotation_matrix_3D(90, Axis.X))\n</code></pre> output<pre><code>[\n    [1, 0, 0],\n    [0, 0, -1],\n    [0, 1, 0]\n]\n</code></pre></p>"},{"location":"algebra/Matrix/#invers","title":"invers","text":"<p><code>classmethod</code></p> <p>Creates the inverse matrix for the matrix.</p> <p>Cr\u00e9e une matrice inverse pour la matrice.</p> <p>(only for quadratic matrices)</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix\n\nm: Matrix = Matrix([[0, 1], [1, 0]])\n\nprint(m.get_invers())\n</code></pre> output<pre><code>[\n    [0, 1],\n    [1, 0]\n]\n</code></pre></p>"},{"location":"algebra/Matrix/#where","title":"where","text":"<p>Creates a matrix whose values are defined by the arg matrix / list, which allows the values from self at a position.</p> <p>Cr\u00e9e une matrice dont les valeurs sont d\u00e9finies par l'arg Matrix, qui autorise les valeurs de self \u00e0 une position.</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix\n\nm: Matrix = Matrix([[1, 2], [3, 4]])\nallowed: Matrix = Matrix([[0, 1], [1, 0]])\n\nprint(m.where(allowed))\n</code></pre> output<pre><code>[\n    [-1, 2],\n    [3, -1]\n]\n</code></pre></p>"},{"location":"algebra/Vector/","title":"Vector","text":"<p>The Vector-class inherits from the Matrix class. It is a simple n-dimensional vector.</p> <p>La classe Vecteur h\u00e9rite de la classe Matrice. Il s'agit d'un simple vecteur \u00e0 n dimensions.</p> <p>Examples:</p> <pre><code>from pylix.algebra import Vector\n\nv: Vector = Vector([1, 2, 3])\n\nprint(v + v)\nprint(v[0])\nprint(v[-1])\n</code></pre> output<pre><code>[2 4 6]\n1\n3\n</code></pre>"},{"location":"algebra/Vector/#cross","title":"cross","text":"<p>Computes the cross product of the vector with another 3D vector.</p> <p>Calcule le produit vectoriel de 2 vecteurs.</p> <p>(only for 3D vector)</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Vector\n\nv1: Vector = Vector([1, 0, 0])\nv2: Vector = Vector([0, 1, 0])\n\nprint(v1.cross(v2))\n</code></pre> output<pre><code>[0 0 1]\n</code></pre></p>"},{"location":"algebra/Vector/#from_matrix","title":"from_matrix","text":"<p><code>classmethod</code></p> <p>Transforms a matrix into a vector.</p> <p>Transforme une matrice en un vecteur.</p> <p>(only if the matrix has row = 1)</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Matrix, Vector\n\nm: Matrix = Matrix([[1], [0], [0]])\n\nprint(Vector.from_matrix(m))\nprint(type(Vector.from_matrix(m)))\n</code></pre> output<pre><code>[1 0 0]\n&lt;class 'useful_utility.algebra.vector.Vector'&gt;\n</code></pre></p>"},{"location":"algebra/Vector/#where","title":"where","text":"<p>Creates a vector whose values are defined by the arg vector / list, which allows the values from self at a position.</p> <p>Cr\u00e9e un vecteur dont les valeurs sont d\u00e9finies par l'arg Vecteur, qui autorise les valeurs de self \u00e0 une position.</p> <p>Example:</p> <p><pre><code>from pylix.algebra import Vector\n\nm: Vector = Vector([1, 2])\nallowed: Vector = Vector([0, 1])\n\nprint(m.where(allowed))\n</code></pre> output<pre><code>[-1 2]\n</code></pre></p>"},{"location":"algebra/Vector/#rand_choice","title":"rand_choice","text":"<p>Returns the index of a randomly chosen element of the list.</p> <p>Renvoie l'indice d'un \u00e9l\u00e9ment de la liste choisi au hasard.</p> <ul> <li>if heat = -1: Chooses nearly always the max</li> <li>if heat =  0: Uses the probability.</li> <li>if heat =  1: Randomises the choice even more.</li> </ul> <p>Example:</p> <p><pre><code>from pylix.algebra import Vector\n\nm: Vector = Vector([.3, .4, .3])\n\nprint(m.rand_choice())\n</code></pre> output<pre><code>1\n</code></pre></p>"},{"location":"algebra/Vector/#sample","title":"sample","text":"<p><code>classmethod</code></p> <p>Creates a vector of the size n with random data from the input vector.</p> <p>Cr\u00e9e un vecteur de taille n avec des donn\u00e9es al\u00e9atoires provenant du vecteur d'entr\u00e9e.</p> <p><pre><code>from pylix.algebra import Vector\n\nm: Vector = Vector([1, 2, 3, 4])\n\nprint(Vector.sample(m, 3))\n</code></pre> output<pre><code>[4 3 1]\n</code></pre></p>"},{"location":"algebra/Vector/#randomise","title":"randomise","text":"<p>Randomises the data of the vector n=1 amount of times.</p> <p>Randomise les donn\u00e9es du vecteur n=1 nombre de fois.</p> <p><pre><code>from pylix.algebra import Vector\n\nm: Vector = Vector([1, 2, 3, 4])\nm.randomise()\nprint(m)\n</code></pre> output<pre><code>[4 2 3 1]\n</code></pre></p>"},{"location":"algebra/statics/","title":"statics","text":""},{"location":"algebra/statics/#rnd","title":"rnd","text":"<p>Returns the rounded value.</p> <p>Renvoie la valeur arrondie.</p> <p>It takes one positional argument, which is the decimal count.</p> <p>Example: <pre><code>from pylix.algebra import rnd\n\nnumber = 5.200_021_895_1\nrounded = rnd(5.200_021_895_1)\nprint(rounded)\n</code></pre></p> output<pre><code>5.200_021_895\n</code></pre> <p>with positional argument</p> <pre><code>from pylix.algebra import rnd\n\nnumber = 5.200_021_895_1\nrounded = rnd(5.200_021_895_1, 6)\nprint(rounded)\n</code></pre> output<pre><code>5.200_022\n</code></pre>"},{"location":"algebra/statics/#average","title":"average","text":"<p>This function calculates the average value of an iterable.</p> <p>Ca fonction calcule l'intersection d'iterable.</p> <p>Example: <pre><code>from pylix.algebra import average\n\nlist_ = [-5, 4, 5, 6, 15]\naverage_ = average(list_)\nprint(average_)\n</code></pre></p> output<pre><code>5\n</code></pre>"},{"location":"algebra/statics/#variance","title":"variance","text":"<p>This function calculates the variance of an iterable.</p> <p>Ca fonction calcule la variance d'iterable.</p> <p>Example: <pre><code>from pylix.algebra import variance\n\nlist_ = [-5, 4, 5, 6, 15]\nvariance_ = variance(list_)\nprint(variance_)\n</code></pre></p> output<pre><code>40.4\n</code></pre>"},{"location":"algebra/statics/#std","title":"std","text":"<p>This function calculates the standard deviation of an iterable.</p> <p>Ca fonction calcule l'\u00e9cart-type d'iterable.</p> <p>Example: <pre><code>from pylix.algebra import std\n\nlist_ = [-5, 4, 5, 6, 15]\nstd_ = std(list_)\nprint(std_)\n</code></pre></p> output<pre><code>6.356_099_433\n</code></pre>"},{"location":"errors/decorator/","title":"decorator","text":""},{"location":"errors/decorator/#todo","title":"TODO","text":"<p>This decorator gives a warning if a not fully implemented function is called, but still executes it.</p> <p>Ce D\u00e9corateur avertit, si une fonction qui n'a pas encore \u00e9t\u00e9 impl\u00e9ment\u00e9e en entier est demand\u00e9e, mais elle     s'ex\u00e9cute quand m\u00eame.</p> <p>Example: <pre><code>from pylix.errors import TODO\n\n@TODO\ndef not_done():\n    print(\"I am doing something.\")\n\nnot_done()\n</code></pre> output<pre><code>&lt;stdin&gt;:7: UserWarning: not_done - TODO: implementation pending.\n  not_done()\nI am doing something.\n</code></pre></p> <p>with custom message: <pre><code>from pylix.errors import TODO\n\n@TODO(\"Needs to be refactored.\")\ndef not_done():\n    print(\"I am doing something.\")\n\nnot_done()\n</code></pre> output<pre><code>&lt;stdin&gt;:7: UserWarning: not_done - TODO: Needs to be refactored.\n  not_done()\nI am doing something.\n</code></pre></p>"}]}